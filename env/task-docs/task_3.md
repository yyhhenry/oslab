# 进程运行轨迹的跟踪与统计

## 实验目的

- 走走停停的特性是进程区别于程序的显著特征，也是理解进程概念的一个直观而有效的视角，因此本实验通过对进程运行轨迹的跟踪来让实验者对进程的概念形象化，这是本实验的基本目的。
- 进程在其生命期中会进行多次状态切换，在这些切换中，就绪态和运行态之间的切换是一类非常重要的切换，会直接导致操作系统的表现行为（如批处理、分时、实时等）。而进程调度正是控制这一切换的关键，因此通过追踪进程在就绪态和运行态之间切换可以从侧面了解进程调度算法（操作系统中最重要的核心算法之一）的行为特性，进而可以对进程调度算法进行评价。因此本实验的第二个基本目标是对进程运行轨迹跟踪的基础上进行相应的数据统计，如统计进程的等待时间（在等待队列中时间），从而能对进程调度算法进行实际的量化评价（如算出平均等待时间），更进一步加深对进程调度概念和调度算法的理解，获得能在实际操作系统上对调度算法进行实验数据对比的直接经验。

## 实验内容

- 在Linux 0.11上实现上述进程运行轨迹的跟踪，基本任务是在Linux 0.11内核中维护一个日志文件`process.log`，要求把从操作系统启动后到操作系统关机的所有的进程的 的运行轨迹（生命轨迹）都记录在这一log文件中，记录的内容可参照上面给出的实例。
- 在进程运行轨迹的跟踪基础上，统计所有进程的等待时间、完成时间、运行时间等信息。然后针对现有的Linux 0.11调度算法，计算该算法导致的平均等待时间，平均完成时间，平均吞吐量等数据。
- 实验者需要修改现有的Linux 0.11调度算法，然后再统计这些时间，并和现有的Linux 0.11调度算法对比，体会调度算法的实验验证。

## 提示

修改`init/main.c`中`void main(void)`在`fork()`之前的代码，提前添加文件描述。

```c
void main(void)
{
    // ...
    /* Add this for precess.log */
    setup((void *)&drive_info);
    (void)open("/dev/tty0", O_RDWR, 0);
    (void)dup(0);
    (void)dup(0);
    (void)open("/var/process.log", O_CREAT | O_TRUNC | O_WRONLY, 0666);

    if (!fork()) {  /* we count on this going ok */
        init();
    }
    // ...
}
```

仿照`printk`实现一个用于记录进程运行轨迹的`log`函数，具体见`kernel/printk.c`中的修改。

修改`kernel/`下的`exit.c`, `fork.c`, `sched.c`等文件，以实现进程运行轨迹的跟踪和统计。

尽量让输出的内容方便反序列化，然后使用Python或其他方便的脚本语言进行统计。

使用shell脚本控制实验内容，这样每次的pid也是一样的，方便统计。
