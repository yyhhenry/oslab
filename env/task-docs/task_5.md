# 地址映射与共享

## 实验目的

- 深入理解操作系统的段、页式内存管理，深入理解段表、页表、逻辑地址、线性地址、物理地址等概念；
- 实践段、页式内存管理的地址映射过程；
- 编程实现段、页式内存管理上的内存共享，从而深入理解操作系统的内存管理。

## 实验内容

- 在保护模式下（启动了分段和分页机制以后）工作的Linux 0.11代码中加上一个内存寻址指令，并且在该内存地址处放置一个自己构造的数据，应用Bochs调试工具跟踪该地址的从逻辑地址、GDT表、线性地址、页表、物理地址的过程，最后验证是否是自己放置的数据？实际上就是手动进行一次地址翻译工作。

- 实现两个进程通过页共享来进行相互通信。

## 提示

手动地址翻译见`exp5/`下的说明文件。

系统调用可以略微简化为一个，也可以添加一个释放共享内存的系统调用。

```c
_syscall3(int, share_memory_with, int, key, int, size, unsigned long *, p_addr);
```

我们假定申请的`size`不能超过`PAGE_SIZE`。

物理内存上的空闲页可以直接`page = get_free_page();`，而用户空间可以使用`sys_brk`来更改堆空间末尾地址，直接增加一页。

注意用`put_page(page, addr)`关联物理页和内存地址时，中的addr需要额外加上`current->start_code`；而使用`put_fs_long(addr, p_addr)`来返回地址的时候，`addr`等于修改前的`current->brk`。

注意在`mm/memory.c`中有关于释放已经释放的页的报错，你需要更改`mem_map`来避免这个问题，可以选择创建`put_page_shared`函数来补充`put_page`做不到的事情，注意更新`mm.h`。

用户程序可以通过`producer &`来启动一个后台进程，然后通过`consumer`来启动一个前台进程，这样就可以实现两个进程的共享内存通信，并同时观察两个进程的输出。
